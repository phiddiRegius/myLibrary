var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { initialize } from "@zappar/zappar-cv";
import { mat4 } from "gl-matrix";
import { VERSION } from "./version";
let _z;
let _options;
export function setOptions(opts) {
    if (_z)
        console.warn("setOptions called after Zappar JS initialization");
    _options = opts;
}
/**
 * @ignore
*/
export function z() {
    if (!_z) {
        console.log(`Zappar JS v${VERSION}`);
        _z = initialize(_options);
    }
    return _z;
}
/**
 * Gets the ID or the default rear- or user-facing camera.
 * @param userFacing - Whether 'selfie' camera ID should be returned.
 * @returns The camera device ID.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices
*/
export function cameraDefaultDeviceID(userFacing) {
    return z().camera_default_device_id(userFacing || false);
}
/**
 * Inverts a 4x4 Float32Array Matrix.
 * @param m - The 4x4 matrix to be inverted.
 * @returns The inverted Float32Array matrix.
*/
export function invert(m) {
    const ret = mat4.create();
    mat4.invert(ret, m);
    return ret;
}
/**
  * Calculates the projection matrix from a given camera model (i.e. intrinsic camera parameters)
  * @param model - The camera model.
  * @param renderWidth - The width of the canvas.
  * @param renderHeight - The height of the canvas.
  * @param zNear - The near clipping plane.
  * @param zFar - The far clipping plane.
  * @returns A 4x4 column-major projection matrix.
 */
export function projectionMatrixFromCameraModel(model, renderWidth, renderHeight, zNear = 0.1, zFar = 100) {
    return z().projection_matrix_from_camera_model_ext(model, renderWidth, renderHeight, zNear, zFar);
}
/**
 * @ignore
*/
export function drawPlane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture) {
    z().draw_plane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture);
}
/**
 * Detects if your page is running in a browser that's not supported
 * @returns 'true' if the browser is incompatible.
*/
export function browserIncompatible() {
    return z().browser_incompatible();
}
/**
 * Shows a full-page dialog that informs the user they're using an unsupported browser,
 * and provides a button to 'copy' the current page URL so they can 'paste' it into the
 * address bar of a compatible alternative.
*/
export function browserIncompatibleUI() {
    z().browser_incompatible_ui();
}
/**
 * Check if the Zappar library is fully loaded and ready to process data.
 * Note that you can still use the full API before this function returns true - it's here to help implement loading screens.
 *
 * @returns 'true' if the library is fully loaded.
*/
export function loaded() {
    return z().loaded();
}
/**
 * Gets a promise that resolves when the Zappar library is fully loaded and ready to process data.
 * Note that you can still use the full API before this promise is resolved - it's here to help implement loading screens.
 *
 * @returns a promise that resolves when the library is fully loaded.
*/
export function loadedPromise() {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            if (loaded())
                return;
            yield delay(50);
        }
    });
}
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
